function A1_IntanFileOrganizer_BL271118

%This function...
%1. reads intan recorded files (*.rhd)
%2. organizes the channels as given by the user
%3. stiches the files if it is necessary
%4. exports the listed channels in the listed order into a .dat file (name given by the user)
%!!! The script reads all *.rhd files within the current folder


%%%%% FOR SPIKE 2 IMPORT FILES USE SINGLE PRECISION AND A SCALING FACTOR OF
%%%%% 0.001


%channel order for export (INTAN identifiers)


% CONFIG: shank Bz1 of 2x32_config_4x8Buzs_4x8disp_1x16Lin.isf
% ch_order = [30 26 21 17 27 22 20 25]+1;
% CONFIG: shank Bz2 of 2x32_config_4x8Buzs_4x8disp_1x16Lin.isf
% ch_order = [28 23 19 24 29 18 31 16]+1;
% CONFIG: shank Bz3 of 2x32_config_4x8Buzs_4x8disp_1x16Lin.isf
% ch_order = [0 15 2 13 8 9 7 1]+1;
% CONFIG: shank Bz4 of 2x32_config_4x8Buzs_4x8disp_1x16Lin.isf
% ch_order = [6 14 10 11 5 12 4 3]+1;
% CONIG: 4x16 linear All channels for Kilosort output
% ch_order = [15 21 11 1 10 19 7 3 6 17 5 4 13 0 2 9, 16 8 23 14 18 12 25 27 20 29 28 31 22 26 30 24, 54 46 48 41 50 44 37 39 35 42 33 34 36 40 38 32, 43 49 63 53 45 52 61 57 47 56 58 59 62 51 55 60]+1;
% CONFIG: 2x4x16 (4shank poly2) linear All channels for Kilosort output
%ch_order = [56 57 58 4 3 2 1 63 0 62 61 60 7 6 5 59, 11 10 9 55 48 49 50 12 51 13 14 15 52 53 54 8, 40 41 42 20 19 18 17 47 16 46 45 44 23 22 21 43, 27 26 25 39 32 33 34 28 35 29 30 31 36 37 38 24, 103 102 101 91 92 93 94 96 95 97 98 99 88 89 90 100, 84 85 86 104 111 110 109 83 108 82 81 80 107 106 105 87, 119 118 117 75 76 77 78 112 79 113 114 115 72 73 74 116, 68 69 70 120 127 126 125 67 124 66 65 64 123 122 121 71]+1;
% ch_order = [3 2 1 63 0 62 61 60 7 6 5 59 4 58 57 56, 11 10 9 55 8 54 53 52 15 14 13 51 12 50 49 48, 19 18 17 47 16 46 45 44 23 22 21 43 20 42 41 40, 27 26 25 39 24 38 37 36 31 30 29 35 28 34 33 32, 92 93 94 96 95 97 98 99 88 89 90 100 91 101 102 103, 84 85 86 104 87 105 106 107 80 81 82 108 83 109 110 111, 76 77 78 112 79 113 114 115 72 73 74 116 75 117 118 119, 68 69 70 71 120 121 122 123 64 65 66 124 67 125 126 127]+1;
% CONFIG: 8_16_8 (3shank Custom) Buz_Lin_Buz All channels for Kilosort output
%ch_order = [30 26 21 17 27 22 20 25, 28 1 23 7 19 9 24 8 29 13 18 2 31 15 16 0, 6 14 10 11 5 12 4 3]+1;
% CONFIG: 2x4x16 (4x32_poly2_20s.isf)linear (2nd row for kilosort without
% the 8 upper single contacts) 
%ch_order = [57 58 3 2 1 63 0 62 61 60 7 6 5 59 4, 10 9 55 48 49 50 12 51 13 14 15 52 53 54 8, 41 42 19 18 17 47 16 46 45 44 23 22 21 43 20, 26 25 39 32 33 34 28 35 29 30 31 36 37 38 24, 102 101 92 93 94 96 95 97 98 99 88 89 90 100 91, 85 86 104 111 110 109 83 108 82 81 80 107 106 105 87, 118 117 76 77 78 112 79 113 114 115 72 73 74 116 75, 69 70 120 127 126 125 67 124 66 65 64 123 122 121 71, 56 11 40 27 103 84 119 68]+1;
%ch_order = [57 58 3 2 1 63 0 62 61 60 7 6 5 59 4, 10 9 55 48 49 50 12 51 13 14 15 52 53 54 8, 41 42 19 18 17 47 16 46 45 44 23 22 21 43 20, 26 25 39 32 33 34 28 35 29 30 31 36 37 38 24, 102 101 92 93 94 96 95 97 98 99 88 89 90 100 91, 85 86 104 111 110 109 83 108 82 81 80 107 106 105 87, 118 117 76 77 78 112 79 113 114 115 72 73 74 116 75, 69 70 120 127 126 125 67 124 66 65 64 123 122 121 71]+1;
%CONFIG: 4x64 Poly2 5mm 23s-250-177
ch_order = [59 5 6 7 0 62 61 60 195 203 211 219 223 215 207 199 3 2 1 63 4 58 57 56 252 244 236 228 224 232 240 248, 8 54 53 52 253 51 13 14 15 198 206 214 222 218 210 202 194 48 49 50 12 55 9 10 11 249 241 233 225 229 237 245, 43 21 22 23 16 46 45 44 254 246 238 230 226 234 242 250 19 18 17 47 20 42 41 40 193 201 209 217 221 213 205 197, 24 38 37 36 255 35 29 30 31 196 204 212 220 216 208 200 192 32 33 34 28 39 25 26 27 251 243 235 227 231 239 247, 100 90 89 88 95 97 98 99 128 136 144 152 156 148 140 132 92 93 94 96 91 101 102 103 191 183 175 167 163 171 179 187, 87 105 106 107 129 108 82 81 80 186 178 170 162 166 174 182 190 111 110 109 83 104 86 85 84 133 141 149 157 153 145 137, 116 74 73 72 79 113 114 115 130 138 146 154 158 150 142 134 76 77 78 112 75 117 118 119 189 181 173 165 161 169 177 185, 71 121 122 123 188 124 66 65 64 135 143 151 159 155 147 139 131 127 126 125 67 120 70 69 68 184 176 168 160 164 172 180]+1;


%external channels (INTAN identifiers)
ch_extra = [];
%scaling factors for channel groups (output units should be millivolts)
sc_amp = 1;
sc_ext = 1;
%output filename
out_filename = 'B216a_Kilo.dat';
%find all *.rhd files in the current directory
tic;
f_dir = dir ('*.rhd');
    
for je=1:size(f_dir,1)
    filename=strcat(f_dir(je,1).name);
    
    % read_Intan_RHD2000_file
    %
    % Version 2.01, 11 October 2017
    %
    % Reads Intan Technologies RHD2000 data file generated by evaluation board
    % GUI or Intan Recording Controller.  Data are parsed and placed into
    % variables that appear in the base MATLAB workspace.  Therefore, it is
    % recommended to execute a 'clear' command before running this program to
    % clear all other variables from the base workspace.
    %
    % Example:
    % >> clear
    % >> read_Intan_RHD2000_file
    % >> whos
    % >> amplifier_channels(1)
    % >> plot(t_amplifier, amplifier_data(1,:))
    
    
    
    % Read most recent file automatically.
    % path = 'C:\Users\Reid\Documents\RHD2132\testing\';
    % d = dir([path '*.rhd']);
    % file = d(end).name;
    
    %%%--------------------------- reading the intan file starts here
    tic;
    fid = fopen(filename, 'r');
    s = dir(filename);
    filesize = s.bytes;
    
    % Check 'magic number' at beginning of file to make sure this is an Intan
    % Technologies RHD2000 data file.
    magic_number = fread(fid, 1, 'uint32');
    if magic_number ~= hex2dec('c6912702')
        error('Unrecognized file type.');
    end
    
    % Read version number.
    data_file_main_version_number = fread(fid, 1, 'int16');
    data_file_secondary_version_number = fread(fid, 1, 'int16');
    
    fprintf(1, '\n');
    fprintf(1, 'Reading Intan Technologies RHD2000 Data File, Version %d.%d\n', ...
        data_file_main_version_number, data_file_secondary_version_number);
    fprintf(1, '\n');
    
    if (data_file_main_version_number == 1)
        num_samples_per_data_block = 60;
    else
        num_samples_per_data_block = 128;
    end
    
    % Read information of sampling rate and amplifier frequency settings.
    sample_rate = fread(fid, 1, 'single');
    dsp_enabled = fread(fid, 1, 'int16');
    actual_dsp_cutoff_frequency = fread(fid, 1, 'single');
    actual_lower_bandwidth = fread(fid, 1, 'single');
    actual_upper_bandwidth = fread(fid, 1, 'single');
    
    desired_dsp_cutoff_frequency = fread(fid, 1, 'single');
    desired_lower_bandwidth = fread(fid, 1, 'single');
    desired_upper_bandwidth = fread(fid, 1, 'single');
    
    % This tells us if a software 50/60 Hz notch filter was enabled during
    % the data acquisition.
    notch_filter_mode = fread(fid, 1, 'int16');
    notch_filter_frequency = 0;
    if (notch_filter_mode == 1)
        notch_filter_frequency = 50;
    elseif (notch_filter_mode == 2)
        notch_filter_frequency = 60;
    end
    
    desired_impedance_test_frequency = fread(fid, 1, 'single');
    actual_impedance_test_frequency = fread(fid, 1, 'single');
    
    % Place notes in data strucure
    notes = struct( ...
        'note1', fread_QString(fid), ...
        'note2', fread_QString(fid), ...
        'note3', fread_QString(fid) );
    
    % If data file is from GUI v1.1 or later, see if temperature sensor data
    % was saved.
    num_temp_sensor_channels = 0;
    if ((data_file_main_version_number == 1 && data_file_secondary_version_number >= 1) ...
            || (data_file_main_version_number > 1))
        num_temp_sensor_channels = fread(fid, 1, 'int16');
    end
    
    % If data file is from GUI v1.3 or later, load eval board mode.
    eval_board_mode = 0;
    if ((data_file_main_version_number == 1 && data_file_secondary_version_number >= 3) ...
            || (data_file_main_version_number > 1))
        eval_board_mode = fread(fid, 1, 'int16');
    end
    
    % If data file is from v2.0 or later (Intan Recording Controller),
    % load name of digital reference channel.
    if (data_file_main_version_number > 1)
        reference_channel = fread_QString(fid);
    end
    
    % Place frequency-related information in data structure.
    frequency_parameters = struct( ...
        'amplifier_sample_rate', sample_rate, ...
        'aux_input_sample_rate', sample_rate / 4, ...
        'supply_voltage_sample_rate', sample_rate / num_samples_per_data_block, ...
        'board_adc_sample_rate', sample_rate, ...
        'board_dig_in_sample_rate', sample_rate, ...
        'desired_dsp_cutoff_frequency', desired_dsp_cutoff_frequency, ...
        'actual_dsp_cutoff_frequency', actual_dsp_cutoff_frequency, ...
        'dsp_enabled', dsp_enabled, ...
        'desired_lower_bandwidth', desired_lower_bandwidth, ...
        'actual_lower_bandwidth', actual_lower_bandwidth, ...
        'desired_upper_bandwidth', desired_upper_bandwidth, ...
        'actual_upper_bandwidth', actual_upper_bandwidth, ...
        'notch_filter_frequency', notch_filter_frequency, ...
        'desired_impedance_test_frequency', desired_impedance_test_frequency, ...
        'actual_impedance_test_frequency', actual_impedance_test_frequency );
    
    % Define data structure for spike trigger settings.
    spike_trigger_struct = struct( ...
        'voltage_trigger_mode', {}, ...
        'voltage_threshold', {}, ...
        'digital_trigger_channel', {}, ...
        'digital_edge_polarity', {} );
    
    new_trigger_channel = struct(spike_trigger_struct);
    spike_triggers = struct(spike_trigger_struct);
    
    % Define data structure for data channels.
    channel_struct = struct( ...
        'native_channel_name', {}, ...
        'custom_channel_name', {}, ...
        'native_order', {}, ...
        'custom_order', {}, ...
        'board_stream', {}, ...
        'chip_channel', {}, ...
        'port_name', {}, ...
        'port_prefix', {}, ...
        'port_number', {}, ...
        'electrode_impedance_magnitude', {}, ...
        'electrode_impedance_phase', {} );
    
    new_channel = struct(channel_struct);
    
    % Create structure arrays for each type of data channel.
    amplifier_channels = struct(channel_struct);
    aux_input_channels = struct(channel_struct);
    supply_voltage_channels = struct(channel_struct);
    board_adc_channels = struct(channel_struct);
    board_dig_in_channels = struct(channel_struct);
    board_dig_out_channels = struct(channel_struct);
    
    amplifier_index = 1;
    aux_input_index = 1;
    supply_voltage_index = 1;
    board_adc_index = 1;
    board_dig_in_index = 1;
    board_dig_out_index = 1;
    
    % Read signal summary from data file header.
    
    number_of_signal_groups = fread(fid, 1, 'int16');
    
    for signal_group = 1:number_of_signal_groups
        signal_group_name = fread_QString(fid);
        signal_group_prefix = fread_QString(fid);
        signal_group_enabled = fread(fid, 1, 'int16');
        signal_group_num_channels = fread(fid, 1, 'int16');
        signal_group_num_amp_channels = fread(fid, 1, 'int16');
        
        if (signal_group_num_channels > 0 && signal_group_enabled > 0)
            new_channel(1).port_name = signal_group_name;
            new_channel(1).port_prefix = signal_group_prefix;
            new_channel(1).port_number = signal_group;
            for signal_channel = 1:signal_group_num_channels
                new_channel(1).native_channel_name = fread_QString(fid);
                new_channel(1).custom_channel_name = fread_QString(fid);
                new_channel(1).native_order = fread(fid, 1, 'int16');
                new_channel(1).custom_order = fread(fid, 1, 'int16');
                signal_type = fread(fid, 1, 'int16');
                channel_enabled = fread(fid, 1, 'int16');
                new_channel(1).chip_channel = fread(fid, 1, 'int16');
                new_channel(1).board_stream = fread(fid, 1, 'int16');
                new_trigger_channel(1).voltage_trigger_mode = fread(fid, 1, 'int16');
                new_trigger_channel(1).voltage_threshold = fread(fid, 1, 'int16');
                new_trigger_channel(1).digital_trigger_channel = fread(fid, 1, 'int16');
                new_trigger_channel(1).digital_edge_polarity = fread(fid, 1, 'int16');
                new_channel(1).electrode_impedance_magnitude = fread(fid, 1, 'single');
                new_channel(1).electrode_impedance_phase = fread(fid, 1, 'single');
                
                if (channel_enabled)
                    switch (signal_type)
                        case 0
                            amplifier_channels(amplifier_index) = new_channel;
                            spike_triggers(amplifier_index) = new_trigger_channel;
                            amplifier_index = amplifier_index + 1;
                        case 1
                            aux_input_channels(aux_input_index) = new_channel;
                            aux_input_index = aux_input_index + 1;
                        case 2
                            supply_voltage_channels(supply_voltage_index) = new_channel;
                            supply_voltage_index = supply_voltage_index + 1;
                        case 3
                            board_adc_channels(board_adc_index) = new_channel;
                            board_adc_index = board_adc_index + 1;
                        case 4
                            board_dig_in_channels(board_dig_in_index) = new_channel;
                            board_dig_in_index = board_dig_in_index + 1;
                        case 5
                            board_dig_out_channels(board_dig_out_index) = new_channel;
                            board_dig_out_index = board_dig_out_index + 1;
                        otherwise
                            error('Unknown channel type');
                    end
                end
                
            end
        end
    end
    
    % Summarize contents of data file.
    num_amplifier_channels = amplifier_index - 1;
    num_aux_input_channels = aux_input_index - 1;
    num_supply_voltage_channels = supply_voltage_index - 1;
    num_board_adc_channels = board_adc_index - 1;
    num_board_dig_in_channels = board_dig_in_index - 1;
    num_board_dig_out_channels = board_dig_out_index - 1;
    
    fprintf(1, 'Found %d amplifier channel%s.\n', ...
        num_amplifier_channels, plural(num_amplifier_channels));
    fprintf(1, 'Found %d auxiliary input channel%s.\n', ...
        num_aux_input_channels, plural(num_aux_input_channels));
    fprintf(1, 'Found %d supply voltage channel%s.\n', ...
        num_supply_voltage_channels, plural(num_supply_voltage_channels));
    fprintf(1, 'Found %d board ADC channel%s.\n', ...
        num_board_adc_channels, plural(num_board_adc_channels));
    fprintf(1, 'Found %d board digital input channel%s.\n', ...
        num_board_dig_in_channels, plural(num_board_dig_in_channels));
    fprintf(1, 'Found %d board digital output channel%s.\n', ...
        num_board_dig_out_channels, plural(num_board_dig_out_channels));
    fprintf(1, 'Found %d temperature sensor channel%s.\n', ...
        num_temp_sensor_channels, plural(num_temp_sensor_channels));
    fprintf(1, '\n');
    
    % Determine how many samples the data file contains.
    
    % Each data block contains num_samples_per_data_block amplifier samples.
    bytes_per_block = num_samples_per_data_block * 4;  % timestamp data
    bytes_per_block = bytes_per_block + num_samples_per_data_block * 2 * num_amplifier_channels;
    % Auxiliary inputs are sampled 4x slower than amplifiers
    bytes_per_block = bytes_per_block + (num_samples_per_data_block / 4) * 2 * num_aux_input_channels;
    % Supply voltage is sampled once per data block
    bytes_per_block = bytes_per_block + 1 * 2 * num_supply_voltage_channels;
    % Board analog inputs are sampled at same rate as amplifiers
    bytes_per_block = bytes_per_block + num_samples_per_data_block * 2 * num_board_adc_channels;
    % Board digital inputs are sampled at same rate as amplifiers
    if (num_board_dig_in_channels > 0)
        bytes_per_block = bytes_per_block + num_samples_per_data_block * 2;
    end
    % Board digital outputs are sampled at same rate as amplifiers
    if (num_board_dig_out_channels > 0)
        bytes_per_block = bytes_per_block + num_samples_per_data_block * 2;
    end
    % Temp sensor is sampled once per data block
    if (num_temp_sensor_channels > 0)
        bytes_per_block = bytes_per_block + 1 * 2 * num_temp_sensor_channels;
    end
    
    % How many data blocks remain in this file?
    data_present = 0;
    bytes_remaining = filesize - ftell(fid);
    if (bytes_remaining > 0)
        data_present = 1;
    end
    
    num_data_blocks = bytes_remaining / bytes_per_block;
    
    num_amplifier_samples = num_samples_per_data_block * num_data_blocks;
    num_aux_input_samples = (num_samples_per_data_block / 4) * num_data_blocks;
    num_supply_voltage_samples = 1 * num_data_blocks;
    num_board_adc_samples = num_samples_per_data_block * num_data_blocks;
    num_board_dig_in_samples = num_samples_per_data_block * num_data_blocks;
    num_board_dig_out_samples = num_samples_per_data_block * num_data_blocks;
    
    record_time = num_amplifier_samples / sample_rate;
    
    if (data_present)
        fprintf(1, 'File contains %0.3f seconds of data.  Amplifiers were sampled at %0.2f kS/s.\n', ...
            record_time, sample_rate / 1000);
        fprintf(1, '\n');
    else
        fprintf(1, 'Header file contains no data.  Amplifiers were sampled at %0.2f kS/s.\n', ...
            sample_rate / 1000);
        fprintf(1, '\n');
    end
    
    if (data_present)
        
        % Pre-allocate memory for data.
        fprintf(1, 'Allocating memory for data...\n');
        
        t_amplifier = zeros(1, num_amplifier_samples);
        
        amplifier_data = zeros(num_amplifier_channels, num_amplifier_samples);
        aux_input_data = zeros(num_aux_input_channels, num_aux_input_samples);
        supply_voltage_data = zeros(num_supply_voltage_channels, num_supply_voltage_samples);
        temp_sensor_data = zeros(num_temp_sensor_channels, num_supply_voltage_samples);
        board_adc_data = zeros(num_board_adc_channels, num_board_adc_samples);
        board_dig_in_data = zeros(num_board_dig_in_channels, num_board_dig_in_samples);
        board_dig_in_raw = zeros(1, num_board_dig_in_samples);
        board_dig_out_data = zeros(num_board_dig_out_channels, num_board_dig_out_samples);
        board_dig_out_raw = zeros(1, num_board_dig_out_samples);
        
        % Read sampled data from file.
        fprintf(1, 'Reading data from file...\n');
        
        amplifier_index = 1;
        aux_input_index = 1;
        supply_voltage_index = 1;
        board_adc_index = 1;
        board_dig_in_index = 1;
        board_dig_out_index = 1;
        
        print_increment = 10;
        percent_done = print_increment;
        for i=1:num_data_blocks
            % In version 1.2, we moved from saving timestamps as unsigned
            % integeters to signed integers to accomidate negative (adjusted)
            % timestamps for pretrigger data.
            if ((data_file_main_version_number == 1 && data_file_secondary_version_number >= 2) ...
                    || (data_file_main_version_number > 1))
                t_amplifier(amplifier_index:(amplifier_index + num_samples_per_data_block - 1)) = fread(fid, num_samples_per_data_block, 'int32');
            else
                t_amplifier(amplifier_index:(amplifier_index + num_samples_per_data_block - 1)) = fread(fid, num_samples_per_data_block, 'uint32');
            end
            if (num_amplifier_channels > 0)
                amplifier_data(:, amplifier_index:(amplifier_index + num_samples_per_data_block - 1)) = fread(fid, [num_samples_per_data_block, num_amplifier_channels], 'uint16')';
            end
            if (num_aux_input_channels > 0)
                aux_input_data(:, aux_input_index:(aux_input_index + (num_samples_per_data_block / 4) - 1)) = fread(fid, [(num_samples_per_data_block / 4), num_aux_input_channels], 'uint16')';
            end
            if (num_supply_voltage_channels > 0)
                supply_voltage_data(:, supply_voltage_index) = fread(fid, [1, num_supply_voltage_channels], 'uint16')';
            end
            if (num_temp_sensor_channels > 0)
                temp_sensor_data(:, supply_voltage_index) = fread(fid, [1, num_temp_sensor_channels], 'int16')';
            end
            if (num_board_adc_channels > 0)
                board_adc_data(:, board_adc_index:(board_adc_index + num_samples_per_data_block - 1)) = fread(fid, [num_samples_per_data_block, num_board_adc_channels], 'uint16')';
            end
            if (num_board_dig_in_channels > 0)
                board_dig_in_raw(board_dig_in_index:(board_dig_in_index + num_samples_per_data_block - 1)) = fread(fid, num_samples_per_data_block, 'uint16');
            end
            if (num_board_dig_out_channels > 0)
                board_dig_out_raw(board_dig_out_index:(board_dig_out_index + num_samples_per_data_block - 1)) = fread(fid, num_samples_per_data_block, 'uint16');
            end
            
            amplifier_index = amplifier_index + num_samples_per_data_block;
            aux_input_index = aux_input_index + (num_samples_per_data_block / 4);
            supply_voltage_index = supply_voltage_index + 1;
            board_adc_index = board_adc_index + num_samples_per_data_block;
            board_dig_in_index = board_dig_in_index + num_samples_per_data_block;
            board_dig_out_index = board_dig_out_index + num_samples_per_data_block;
            
            fraction_done = 100 * (i / num_data_blocks);
            if (fraction_done >= percent_done)
                fprintf(1, '%d%% done...\n', percent_done);
                percent_done = percent_done + print_increment;
            end
        end
        
        % Make sure we have read exactly the right amount of data.
        bytes_remaining = filesize - ftell(fid);
        if (bytes_remaining ~= 0)
            %error('Error: End of file not reached.');
        end
        
    end
    
    % Close data file.
    fclose(fid);
    
    if (data_present)
        
        fprintf(1, 'Parsing data...\n');
        
        % Extract digital input channels to separate variables.
        for i=1:num_board_dig_in_channels
            mask = 2^(board_dig_in_channels(i).native_order) * ones(size(board_dig_in_raw));
            board_dig_in_data(i, :) = (bitand(board_dig_in_raw, mask) > 0);
        end
        for i=1:num_board_dig_out_channels
            mask = 2^(board_dig_out_channels(i).native_order) * ones(size(board_dig_out_raw));
            board_dig_out_data(i, :) = (bitand(board_dig_out_raw, mask) > 0);
        end
        
        % Scale voltage levels appropriately.
        amplifier_data = 0.195 * (amplifier_data - 32768); % units = microvolts
        aux_input_data = 37.4e-6 * aux_input_data; % units = volts
        supply_voltage_data = 74.8e-6 * supply_voltage_data; % units = volts
        if (eval_board_mode == 1)
            board_adc_data = 152.59e-6 * (board_adc_data - 32768); % units = volts
        elseif (eval_board_mode == 13) % Intan Recording Controller
            board_adc_data = 312.5e-6 * (board_adc_data - 32768); % units = volts
        else
            board_adc_data = 50.354e-6 * board_adc_data; % units = volts
        end
        temp_sensor_data = temp_sensor_data / 100; % units = deg C
        
        % Check for gaps in timestamps.
        num_gaps = sum(diff(t_amplifier) ~= 1);
        if (num_gaps == 0)
            fprintf(1, 'No missing timestamps in data.\n');
        else
            fprintf(1, 'Warning: %d gaps in timestamp data found.  Time scale will not be uniform!\n', ...
                num_gaps);
        end
        
        % Scale time steps (units = seconds).
        t_amplifier = t_amplifier / sample_rate;
        t_aux_input = t_amplifier(1:4:end);
        t_supply_voltage = t_amplifier(1:num_samples_per_data_block:end);
        t_board_adc = t_amplifier;
        t_dig = t_amplifier;
        t_temp_sensor = t_supply_voltage;
        
        % If the software notch filter was selected during the recording, apply the
        % same notch filter to amplifier data here.
        if (notch_filter_frequency > 0)
            fprintf(1, 'Applying notch filter...\n');
            
            print_increment = 10;
            percent_done = print_increment;
            for i=1:num_amplifier_channels
                amplifier_data(i,:) = ...
                    notch_filter(amplifier_data(i,:), sample_rate, notch_filter_frequency, 10);
                
                fraction_done = 100 * (i / num_amplifier_channels);
                if (fraction_done >= percent_done)
                    fprintf(1, '%d%% done...\n', percent_done);
                    percent_done = percent_done + print_increment;
                end
                
            end
        end
        
    end
    
    % Move variables to base workspace.
    
    % new for version 2.01: move filename info to base workspace
    move_to_base_workspace(filename);
    move_to_base_workspace(notes);
    move_to_base_workspace(frequency_parameters);
    if (data_file_main_version_number > 1)
        move_to_base_workspace(reference_channel);
    end
    
    if (num_amplifier_channels > 0)
        move_to_base_workspace(amplifier_channels);
        if (data_present)
            move_to_base_workspace(amplifier_data);
            move_to_base_workspace(t_amplifier);
        end
        move_to_base_workspace(spike_triggers);
    end
    if (num_aux_input_channels > 0)
        move_to_base_workspace(aux_input_channels);
        if (data_present)
            move_to_base_workspace(aux_input_data);
            move_to_base_workspace(t_aux_input);
        end
    end
    if (num_supply_voltage_channels > 0)
        move_to_base_workspace(supply_voltage_channels);
        if (data_present)
            move_to_base_workspace(supply_voltage_data);
            move_to_base_workspace(t_supply_voltage);
        end
    end
    if (num_board_adc_channels > 0)
        move_to_base_workspace(board_adc_channels);
        if (data_present)
            move_to_base_workspace(board_adc_data);
            move_to_base_workspace(t_board_adc);
        end
    end
    if (num_board_dig_in_channels > 0)
        move_to_base_workspace(board_dig_in_channels);
        if (data_present)
            move_to_base_workspace(board_dig_in_data);
            move_to_base_workspace(t_dig);
        end
    end
    if (num_board_dig_out_channels > 0)
        move_to_base_workspace(board_dig_out_channels);
        if (data_present)
            move_to_base_workspace(board_dig_out_data);
            move_to_base_workspace(t_dig);
        end
    end
    if (num_temp_sensor_channels > 0)
        if (data_present)
            move_to_base_workspace(temp_sensor_data);
            move_to_base_workspace(t_temp_sensor);
        end
    end
    
    fprintf(1, 'Done!  Elapsed time: %0.1f seconds\n', toc);
    if (data_present)
        fprintf(1, 'Extracted data are now available in the MATLAB workspace.\n');
    else
        fprintf(1, 'Extracted waveform information is now available in the MATLAB workspace.\n');
    end
    fprintf(1, 'Type ''whos'' to see variables.\n');
    fprintf(1, '\n');
    
    %%%-INTAN reading ends here
    if je==1
        tm_stich = t_amplifier;
        dt_stich = [amplifier_data(ch_order,:).*sc_amp; board_adc_data(ch_extra,:)];
        
    else
        tm_stich = [tm_stich t_amplifier];
        dt_stich = [dt_stich [amplifier_data(ch_order,:).*sc_amp; board_adc_data(ch_extra,:)]];
    end
    
end

%moving the relevant files to
move_to_base_workspace(tm_stich)
move_to_base_workspace(dt_stich)

%saving the relevant files
%saving data file int16 format for kilosort and single for the Spike2 import 
save(out_filename);
fid=fopen(out_filename, 'w');
%fwrite(fid,dt_stich,'single');
 fwrite(fid,dt_stich,'int16');
fclose(fid);

save (strrep(out_filename, '.dat','.mat'), 'ch_order', 'tm_stich', 'f_dir','-v7.3')
return

function a = fread_QString(fid)

% a = read_QString(fid)
%
% Read Qt style QString.  The first 32-bit unsigned number indicates
% the length of the string (in bytes).  If this number equals 0xFFFFFFFF,
% the string is null.

a = '';
length = fread(fid, 1, 'uint32');
if length == hex2num('ffffffff')
    return;
end
% convert length from bytes to 16-bit Unicode words
length = length / 2;

for i=1:length
    a(i) = fread(fid, 1, 'uint16');
end

return


function s = plural(n)

% s = plural(n)
% 
% Utility function to optionally plurailze words based on the value
% of n.

if (n == 1)
    s = '';
else
    s = 's';
end

return


function out = notch_filter(in, fSample, fNotch, Bandwidth)

% out = notch_filter(in, fSample, fNotch, Bandwidth)
%
% Implements a notch filter (e.g., for 50 or 60 Hz) on vector 'in'.
% fSample = sample rate of data (in Hz or Samples/sec)
% fNotch = filter notch frequency (in Hz)
% Bandwidth = notch 3-dB bandwidth (in Hz).  A bandwidth of 10 Hz is
%   recommended for 50 or 60 Hz notch filters; narrower bandwidths lead to
%   poor time-domain properties with an extended ringing response to
%   transient disturbances.
%
% Example:  If neural data was sampled at 30 kSamples/sec
% and you wish to implement a 60 Hz notch filter:
%
% out = notch_filter(in, 30000, 60, 10);

tstep = 1/fSample;
Fc = fNotch*tstep;

L = length(in);

% Calculate IIR filter parameters
d = exp(-2*pi*(Bandwidth/2)*tstep);
b = (1 + d*d)*cos(2*pi*Fc);
a0 = 1;
a1 = -b;
a2 = d*d;
a = (1 + d*d)/2;
b0 = 1;
b1 = -2*cos(2*pi*Fc);
b2 = 1;

out = zeros(size(in));
out(1) = in(1);  
out(2) = in(2);
% (If filtering a continuous data stream, change out(1) and out(2) to the
%  previous final two values of out.)

% Run filter
for i=3:L
    out(i) = (a*b2*in(i-2) + a*b1*in(i-1) + a*b0*in(i) - a2*out(i-2) - a1*out(i-1))/a0;
end

return


function move_to_base_workspace(variable)

% move_to_base_workspace(variable)
%
% Move variable from function workspace to base MATLAB workspace so
% user will have access to it after the program ends.

variable_name = inputname(1);
assignin('base', variable_name, variable);

return
return;


    
    







